from moviepy.video.io.VideoFileClip import VideoFileClip
from faster_whisper import WhisperModel
import os
import google.generativeai as genai
import whisper


# 配置Gemini API（请替换为您的实际API密钥）
def configure_gemini_api():
    genai.configure(api_key="AIzaSyDXTjBu00nQP0V5B-CTwVzZylDeXQW3VqY")  # 请替换为您的API密钥
    return genai.GenerativeModel('gemini-2.0-flash')

# 使用Gemini 2.0 Pro翻译文本
def translate_with_gemini(model, text, source_lang="ja", target_lang="zh"):
    prompt = (
        f"请将以下{source_lang}文本翻译为{target_lang}，要求表达自然、接地气、口语化，不要太书面语，"
        f"并且不要输出任何解释、格式说明或其他无关内容，仅输出翻译结果：\n{text}"
    )
    response = model.generate_content(prompt)
    return response.text.strip()

# 从视频中提取音频
def extract_audio(video_path, audio_path="temp_audio.wav"):
    video = VideoFileClip(video_path)
    audio = video.audio
    audio.write_audiofile(audio_path)
    video.close()
    audio.close()

# fast_whisper转录音频：返回句子及对应的起止时间
def transcribe_with_fast_whisper(audio_path):
    model = WhisperModel("large-v2", device="cuda", compute_type="float32")
    segments, _ = model.transcribe(audio_path, beam_size=5, language="ja")

    results = []
    for segment in segments:
        start = segment.start
        end = segment.end
        text = segment.text.strip()
        results.append((start, end, text))
    return results

#whisper转录音频：返回句子及对应的起止时间
def transcribe_with_whisper(audio_path):
    model = whisper.load_model("large-v3", device="cuda")
    result = model.transcribe(audio_path, beam_size=5, language="ja")

    results = []
    for segment in result["segments"]:
        start = segment["start"]
        end = segment["end"]
        text = segment["text"].strip()
        results.append((start, end, text))
    return results

# 将秒数格式化为ASS字幕时间（格式：h:mm:ss.cc）
def format_ass_time(seconds):
    h = int(seconds // 3600)
    m = int((seconds % 3600) // 60)
    s = int(seconds % 60)
    cs = int((seconds - int(seconds)) * 100)
    return f"{h}:{m:02d}:{s:02d}.{cs:02d}"

# 创建包含原始和翻译文本的ASS字幕文件
def create_new_ass(segments, translations, output_path):
    header = """[Script Info]
Title: Generated by Whisper with Gemini Translation
ScriptType: v4.00+
Collisions: Normal
PlayResX: 1920
PlayResY: 1080
Timer: 100.0000

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,微软雅黑,60,&H00FFFFFF,&H000000FF,&H00000000,&H64000000,-1,0,0,0,100,100,0,0,1,2.0,2.0,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
"""
    dialogue_lines = []
    for (start, end, text), translated_text in zip(segments, translations):
        start_ts = format_ass_time(start)
        end_ts = format_ass_time(end)
        # 原始字幕（使用 Default 样式）
        original_line = f"Dialogue: 0,{start_ts},{end_ts},Default,,0,0,0,,{text}"
        # 翻译字幕（使用 Default 样式）
        translated_line = f"Dialogue: 0,{start_ts},{end_ts},Default,,0,0,0,,{translated_text}"
        dialogue_lines.append(original_line)
        dialogue_lines.append(translated_line)

    with open(output_path, "w", encoding="utf-8") as f:
        f.write(header + "\n".join(dialogue_lines))

# 主流程
def main():
    video_path = input("视频文件地址：").strip().strip('"').strip("'")
    audio_path = "temp_audio.wav"
    output_ass_path = os.path.splitext(video_path)[0] + ".ass"

    # 提取音频
    extract_audio(video_path, audio_path)
    print("音频提取完成，开始语音识别...")

    # fast_whisper转录音频
    #segments = transcribe_with_fast_whisper(audio_path)
    #print("识别完成，翻译字幕...")

    # whisper转录音频
    segments = transcribe_with_whisper(audio_path)
    print("识别完成，翻译字幕...")

    # 翻译字幕
    gemini_model = configure_gemini_api()
    translations = [translate_with_gemini(gemini_model, text) for _, _, text in segments]
    print("翻译完成，生成字幕文件...")

    # 创建包含原始和翻译字幕的ASS文件
    create_new_ass(segments, translations, output_ass_path)
    print("字幕文件已保存到：", output_ass_path)

    # 清理临时音频文件
    if os.path.exists(audio_path):
        os.remove(audio_path)

if __name__ == "__main__":
    main()